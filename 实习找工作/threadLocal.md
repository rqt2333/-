## ThreadLocal核心知识点总结

### 1.ThreadLocal解决的问题

1. 作用：做线程隔离，就是让每个线程都有自己的副本
2. 导致并发安全问题的本质：
   * 多线程同时执行
   * 执行的是同一个变量

3. 如何解决并发安全问题：
   * 通过加锁让线程不同时执行
   * 当线程处理同一个共享变量时，将该变量复制一份，让每个线程都有自己的独有变量，这就破坏了第二个条件。



### 2.ThreadLocal核心知识点

1. ThreadLocal解决并发问题的流程就是将共享变量进行拷贝，每个线程都拷贝一份，拷贝完了就放在线程的口袋里面。
2. 口袋是什么——就是一个存储数据的结构（Hash表，它的真实名字是 **ThreadLocalMap**） 
3. Hash表是什么？
   * 就是一个特殊的数组，特俗的点在于数组的下标是通过 hash运算求的

4. ThreadLocal的应用
   * 创建对象
   * 调用set()方法
   * 调用get()方法

5. ThreadLocalMap的数组的默认长度是多少？    16个。

6. ThreadLocalMap 的默认扩容因子是多少？     2/3。

7. java中存在几种引用类型？

   * 强引用：通过new 关键字创建的对象,即使内存不够，也不会回收

   * 软引用：内存不够就回收，内存够就不回收

     ```java
     Object o = new Object();
     SoftReference softReference = new SoftReference(o);
     ```

   * 弱引用：不管内存够不够，都回收

   * 虚引用：

8. 为什么ThreadLocalMap中的key为什么要使用弱引用？使用弱引用就会安全了吗？

   假设key也是强引用，那么如果外界的引用变为null了，那么里面的对象就无法获取到了。而该对象是会随着线程的灭亡而灭亡的，如果线程不灭亡，那么该对象就用于不能回收，所以我们要使用弱引用，来**减少内存泄漏**。

   使用弱引用也会发生安全问题，因为**Value** 是强引用。

9. ThreadLocal如何解决内存泄漏？

   调用remove()方法。









