#### 1.java三大特性？详细讲讲？

* **封装** ：指的是把一个对象的状态信息（或者属性）隐藏在这个对象的内部，不允许外部直接访问我们的内部信息。但是我们可以提供接口来给外部访问。
* **继承** ：不同类型之间的对象，相互之间有一些共同点，因此我们可以在使用已存在的类作为基础定义新的类，该类可以使用父类的功能，可以拥有父类的属性。这样可以提高代码的开发效率。
* **多态** ：顾名思义，就是一个对象具有多种形态。具体的说，就是父类的引用指向子类的对象。在java中，实现多态有多种方式，一种是编译时的多态，一种是运行时的多态。**编译时的多态是通过方法的重载来确定的，运行时的多态是通过重写来确定的。**方法的重写，子类重写父类中的方法（包括接口的实现） ，父类的引用不仅可以指向父类的对象，还可以指向子类的对象。当父类的引用指向子类的对象时，只有运行时才能确定调用的是哪个方法。

#### 2.public private protected default之间的区别？

* **public** ：是权限最大的修饰符，对所有类可见。使用对象：类，接口，方法，变量。

* **protected** ：对同一个包内的类和所有子类可见。使用对象：变量，方法。**注意：不能修饰类（外部类）**。 

* **default** ：默认，即什么也不写。在同一包内可见。使用对象：类，接口，方法，变量。

* **private** ：在同一类内可见。使用对象：变量，方法。**注意：不能修饰类（外部类）**。 

  ![image-20230321213302875](C:\Users\rqt\AppData\Roaming\Typora\typora-user-images\image-20230321213302875.png)

  

#### 3.多线程用过吗？用在哪里？

用过。举例子：

1. 比如说博客项目系统中，点击进去看文章的时候，主线程关心的是文章的加载出来这一件事情，但是文章加载出来这件事情会有伴生行为，比如说你点击查看一次文章，那么观看量就会增加一次，这个时候**观看量增加**这个操作我们如果写在加载文章这个线程方法里面的话，那么无疑效率是很慢的，因为观看量是次要的，最主要的任务是把文章加载出来。因此针对这种情况，我们可以新开一个线程，比如说放到线程池中去执行，这样就不会影响到主线程了，从而提高效率。
2. 还有，比如我们在登录，或者修改订单的时候，往往需要记录日志，这个时候我们可以将记录日志这个行为交给异步线程来做。
3. UI编程。曾经用javafx来绘制界面，为了不阻塞主线程让用户体验更刘畅，需要创建单独的线程来处理耗时操作。又比如说在坦克大战中，两个坦克的运行方向和射击方向都是不同的线程来控制。
4. 将大量文件写入数据库中，可以对文件进行分割，然后利用多个线程写入。需要记住每个分割文件的起始和末尾位置。

#### 4.ArrayList 跟 LinkedList 区别？

* **是否线程安全** ：两者都是线程不安全的。
* **底层数据结构** ： ArrayList 是 Object类型的数组，LinkedList 使用的是**双向链表**（JDK1.6之前为循环链表，JDK1.7之后取消了循环）。
* **插入、删除元素的位置** ：`ArrayList` 采用数组存储，如果插入在最后一位，那么时间复杂度是`O(1)`，但是如果要在某个位置插入或删除元素，那么会涉及到元素的移动，时间复杂度是`O(n)` 。`LinkedList` 采用链表存储，如果要在头尾插入或删除，时间复杂度是`O(1)`，但是要在指定位置插入或删除，那么需要先移动到指定的位置，因此时间复杂度是`O(n)` 。
* **是否支持随机访问** ：`ArrayList` 支持随机访问，`LinkedList` 不支持。
* **内存空间占用** ：`LinkedList` 每一个元素会比`ArrayList` 多占用内存空间，因为每一个节点都要存储直接前驱和直接后继和数据部分；`ArrayList` 内存空间浪费主要在于列表结尾会预留一定的空间。

#### 5.Redis如何做分布式锁？

对于单机多线程来说，我们通常使用`ReentranLock` ,`Sychornized` 等来控制多个进程对共享资源的访问，这是一种本地锁。但是到了分布式的环境下，多台机器操控同一份共享资源的话，那么本地锁就没有用了，因为本地锁基于JVM，而分布式是基于多个JVM，所以我们需要用到分布式锁。

以下是实现分布式锁的步骤：

* **客户端请求加锁** ：客户端使用 `SETNX` 命令，如果返回值为1，表示获取锁成功，如果返回值为0，则表示获取锁失败。
* **设置过期时间** ：为了避免因客户端崩溃等原因导致锁不能释放（死锁问题），需要为锁设置过期时间。可以使用 `EXPIRE` 命令设置过期时间。
* **客户端请求解锁** ：完成业务之后，需要解锁，让别的线程进来竞争共享资源。客户端使用 `DEL` 命令释放锁，但是需要确保只有持有锁的客户端才能释放锁。可以使用 Lua脚本实现解锁操作，通过比较锁的值和客户端提供的值来确定是否释放锁。



**如果操作共享资源的时间大于过期时间，那么就会出现锁提前过期的问题，进而分布式锁失效，但是如果设置时间过长，又会影响性能，该怎么办呢？**

使用 Redisson。

Redisson中的分布式锁自带自动续期机制。其提供了一个专门用来监控和续期锁的 Watch Dog （看门狗）实际上就是一个守护线程。如果操作共享资源的线程还未执行完成的话，**看门狗会不断的延长锁的过期时间，进而保证锁不会因为超时而被释放**。





